package game;

import java.awt.*;

class Face {
    private final double[][] vertices = new double[4][3];     // 4 vertices, each is (x, y, z)
    private final Color baseColor;
    private Color currentColor;

    public Face(double[] v1, double[] v2, double[] v3, double[] v4, Color baseColor) {
        this.vertices[0] = v1;
        this.vertices[1] = v2;
        this.vertices[2] = v3;
        this.vertices[3] = v4;
        this.baseColor = baseColor;
        this.currentColor = baseColor;
    }

    public double[] calculateCenter() {
        double[] center = new double[3];

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                center[i] += vertices[j][i];
            }
            center[i] /= 4;
        }

        return center;
    }

    public boolean isVisible(double cameraX, double cameraY, double cameraZ) {
        double[] normal = calculateNormal();
        double[] faceCenter = calculateCenter();
        double[] toCamera = vectorToCamera(faceCenter, cameraX, cameraY, cameraZ);

        // Face is visible only if scalar product > 0
        double dotProduct = normal[0] * toCamera[0] + normal[1] * toCamera[1] + normal[2] * toCamera[2];

        return dotProduct > 0;
    }

    private double[] calculateNormal() {
        double[] v1 = vertices[0];
        double[] v2 = vertices[1];
        double[] v3 = vertices[2];

        // Two orthogonal vectors generated by three vertices
        double[] vector1 = new double[] {v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]};
        double[] vector2 = new double[] {v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]};

        // Cross product
        return new double[] {
                vector1[1] * vector2[2] - vector1[2] * vector2[1],      // x
                vector1[2] * vector2[0] - vector1[0] * vector2[2],      // y
                vector1[0] * vector2[1] - vector1[1] * vector2[0]       // z
        };
    }

    private double[] vectorToCamera(double[] center, double cameraX, double cameraY, double cameraZ) {
        return new double[] {
                cameraX - center[0],
                cameraY - center[1],
                cameraZ - center[2]
        };
    }

    public double distanceToCamera(double cameraX, double cameraY, double cameraZ) {
        double[] center = calculateCenter();
        return Math.sqrt(Math.pow(center[0] - cameraX, 2) + Math.pow(center[1] - cameraY, 2) + Math.pow(center[2] - cameraZ, 2));
    }

    public double[][] getVertices() {
        return vertices;
    }

    public Color getBaseColor() {
        return baseColor;
    }

    public Color getCurrentColor() {
        return currentColor;
    }

    public void setCurrentColor(Color currentColor) {
        this.currentColor = currentColor;
    }
}
